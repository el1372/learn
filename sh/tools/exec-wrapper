#!/bin/sh
#description: creates setuid-wrappers for scripts and other executables
#http://code.google.com/p/exec-wrapper

#usage: exec-wrapper script

#example: exec-wrapper -v files.tar.gz
#file1
#file2
#...

################################################################################
#
#   Copyright (C) 2009 Ivan Mironov <mironov.ivan@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

PROGNAME="$(expr "${0}" : '.*/\([^/]*\)')"
CC="${CC:-cc}" #default compiler

DEST="."
MODE="4750"   # -rwsr-x---
MODE_A="4755" # -rwsr-xr-x

_basename() {
    #basename portable version
    [ -z "${1}" ] && return 1 || _basename__name="${1}"
    [ -z "${2}" ] || _basename__suffix="${2}"
    case "${_basename__name}" in
        /*|*/*) _basename__name="${_basename__name##*/}"
    esac

    if [ -n "${_basename__suffix}" ] && [ "${#_basename__name}" -gt "${#2}" ]; then
        _basename__name="${_basename__name%$_basename__suffix}"
    fi

    printf "%s" "${_basename__name}"
}

_usage() {
    printf "%s\\n" "Usage: $(_basename "${0}") [options] script|executable [wrapper-name]"
    printf "%s\\n" "Creates setuid-wrappers for scripts and other executables."
    printf "\\n"
    printf "%s\\n" "  -A  use 4755 (-rwsr-xr-x) permissions"
    printf "%s\\n" "  -E  create wrapper with an empty environment"
    printf "%s\\n" "  -s  print generated wrapper C source and exit"
    printf "\\n"
    printf "%s\\n" "  -d  destination directory"
    printf "%s\\n" "  -m  mode"
    printf "%s\\n" "  -o  owner"
    printf "%s\\n" "  -g  group"
    printf "%s\\n" "  -a  argument"
    printf "%s\\n" "  -e  ENVVAR=value"
    printf "%s\\n" "  -u  ENVVAR"
    printf "\\n"
    printf "%s\\n" "  -q  quiet mode"
    printf "%s\\n" "  -h  show this help message and exit"
}

_die() {
    printf "%s\\n" "ERROR: ${1}" >&2
    [ "x${tmp}" != "x" ] && rm -rf "${tmp}"
    exit 1
}

_verbose() {
    #print a message when in verbose mode
    [ -z "${1}" ] && return 1
    [ -z "${QUIET}" ] && printf "%s\\n" "${*}"
}

_seq() {
    for _seq__arg; do
        case "${_seq__arg}" in
            *[!0-9-]*|"") return 1 ;;
        esac
    done

    [ -z "${1}" ] && return 1

    _seq__first="1"; _seq__increment="1"; _seq__last="${1}"

    if [ "${#2}" -gt "0" ]; then
        _seq__first="${1}"
        _seq__last="${2}"
    fi

    if [ "${#3}" -gt "0" ]; then
        _seq__first="${1}"
        _seq__increment="${2}"
        _seq__last="${3}"
    fi

    while [ "$_seq__first" -le "${_seq__last}" ]; do
        printf "%s\\n" "${_seq__first}"
        _seq__first="$((_seq__first + _seq__increment))"
    done
}

_mkdir_p() { #portable mkdir -p function
    for _mkdir_p__dir; do
        _mkdir_p__IFS="$IFS"
        IFS="/"
        set -- $_mkdir_p__dir
        IFS="$_mkdir_p__IFS"
        (
        case "$_mkdir_p__dir" in
            /*) cd /; shift ;;
        esac
        for _mkdir_p__subdir; do
            [ -z "${_mkdir_p__subdir}" ] && continue
            if [ -d "${_mkdir_p__subdir}" ] || mkdir "${_mkdir_p__subdir}"; then
                if cd "${_mkdir_p__subdir}"; then
                    :
                else
                    printf "%s\\n" "_mkdir_p: Can't enter ${_mkdir_p__subdir} while creating ${_mkdir_p__dir}"
                    exit 1
                fi
            else
                exit 1
            fi
        done
        )
    done
    unset _mkdir_p__dir
}

#convert string to escaped octal codes
#$1 - string
#stdout - escaped string
_str2octal_escaped() {
    [ -z "${1}" ] && return 1
    printf "%s" "${1}" | od -v -A n -t o1 | tr -d "\n" | \
        sed "s/ *\([0-9]*\) */\\\\\1/g" | tr -d "\n"
}

#Generate wrapper source code.
#$1 - real executable.
_generate_source() {
    cat << EOF
/************************************************************************/
/* autogenerated by exec-wrapper, http://code.google.com/p/exec-wrapper */
/************************************************************************/

/* for putenv(). */
#define _SVID_SOURCE
#define _XOPEN_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

EOF
    #file name of executable
    printf "static const char *const real_exec = \""
    _str2octal_escaped "${1}"
    printf "\";\n\n"

    cat << EOF
static void printErr()
{
    fprintf(stderr, "\"%s\" wrapper error: %s (code %d)\n",
        real_exec, strerror(errno), errno);
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
EOF
    #for additions arguments and C90.
    if [ "${ARG_NUM}" -gt "0" ]; then
        printf "    int i;\n"
        printf "    char **new_argv;\n"
    fi

    if [ "x${EMPTY_ENV}" != "x" ]; then
        #empty environment
        printf "    char *new_envp[] = {NULL};\n"
        _gsource__envp="new_envp"
    else
        printf "    extern char **environ;\n"

        #set environment variables
        i=""; for i in $(_seq "${ENV_NUM}" ); do
            printf "    if (putenv(\""
            eval _str2octal_escaped \"\${ENV_$i}\"
            printf "\"))\n"
            printf "        printErr();\n"
        done

        #unset environment variables
        for i in $(_seq $UENV_NUM ); do
            printf "    if (unsetenv(\""
            eval _str2octal_escaped \"\${UENV_$i}\"
            printf "\"))\n"
            printf "        printErr();\n"
        done

        _gsource__envp="environ"
    fi

    #additions arguments
    if [ "${ARG_NUM}" -gt "0" ]; then
        printf "    new_argv = "
        printf "malloc(sizeof(*new_argv) * (argc + %s + 1));\n" "${ARG_NUM}"

        printf "    new_argv[0] = argv[0];\n"

        i=""; for i in $(_seq "${ARG_NUM}" ); do
            printf "    new_argv[%s] = \"" "${i}"
            eval _str2octal_escaped \"\${ARG_$i}\"
            printf "\";\n"
        done
        printf "    for (i = 1; i <= argc; ++i)\n"
        printf "        new_argv[i + %s] = argv[i];\n" "${ARG_NUM}"

        _gsource__argv="new_argv"
    else
        printf "    (void) argc;\n"
        _gsource__argv="argv"
    fi

    cat << EOF
    execve(real_exec, ${_gsource__argv}, ${_gsource__envp});
    printErr();
    return 0;
}
EOF
}

_check_utils() {
    for _cutils__arg; do
        command -v "${_cutils__arg}" >/dev/null 2>&1 || \
            _die "\"${_cutils__arg}\" is not available, aborting..."
    done
}

#check utils and abort if dependencies are not available
_check_utils rm od sed tr chmod install id "${CC}"

#default owner and group.
OWNER="$(id -un)"
GROUP="$(id -gn)"
#read command line options.
ARG_NUM="0"
ENV_NUM="0"
UENV_NUM="0"

if [ ! -t 0 ]; then
    #there is input comming from pipe or file, add to the end of $@
    set -- "${@}" $(cat)
fi

[ "${#}" = "0" ] && _usage >&2 && exit 1

for arg in "${@}"; do #parse options
    case "${arg}" in
        -h|--help) _usage && exit ;;
        --*) printf "%s\\n" "Illegal option '${arg}'" >&2
             _die "Try ${PROGNAME} -h" ;;
    esac
done

while getopts "hqAEsd:m:o:g:a:e:u:" opt >&2; do
    case "${opt}" in
        "q") QUIET="X";;
        "A") MODE="${MODE_A}";;
        "E") EMPTY_ENV="X";;
        "s") PRINT_SOURCE="X";;
        "d") DEST="${OPTARG}";;
        "m") MODE="${OPTARG}";;
        "o") OWNER="${OPTARG}";;
        "g") GROUP="${OPTARG}";;
        "a") ARG_NUM="$(($ARG_NUM + 1))"
             eval ARG_$ARG_NUM=\"\${OPTARG}\" ;;
        "e") ENV_NUM="$(($ENV_NUM + 1))"
             eval ENV_$ENV_NUM=\"\${OPTARG}\" ;;
        "u") UENV_NUM="$(($UENV_NUM + 1))"
             eval UENV_$UENV_NUM=\"\${OPTARG}\" ;;
          *) _die "Try ${PROGNAME} -h" ;;
    esac
done

shift "$(($OPTIND - 1))"

if [ "${#}" -lt "1" ] || [ "${#}" -gt "2" ]; then
    printf "%s\\n" "Missing arguments" >&2
    _usage >&2; exit 1
fi

REAL="${1}"
WRAPPER="${2}"

[ "x${DEST}"  = "x" ] && _die "Empty destination path"
[ "x${MODE}"  = "x" ] && _die "Empty file mode"
[ "x${OWNER}" = "x" ] && _die "Empty file owner"
[ "x${GROUP}" = "x" ] && _die "Empty file group"
[ "x${REAL}"  = "x" ] && _die "Empty executable path"

#get full path to script
real_base=$(_basename "${REAL}")
[ "x${REAL}" = "x${real_base}" ] && REAL=$(command -v "${REAL}" )
[ "x${REAL}" = "x" ] && _die "Executable '${1}' not found in \$PATH"

#get full path to wrapper binary
[ "x${WRAPPER}" = "x" ] && WRAPPER=$(_basename "${REAL}" )
wrapper_base=$(_basename "${WRAPPER}" )
[ "x${WRAPPER}" = "x${wrapper_base}" ] && WRAPPER="${DEST}/${WRAPPER}"

if [ "x${PRINT_SOURCE}" != "x" ]; then
    #print source and exit
    _generate_source "${REAL}"
    exit 0
fi

[ -e "${WRAPPER}" ] && _die "File '${WRAPPER}' already exists"

#create directory for temporary files
tmp="$(mktemp -d exec-wrapper.XXXXXXXXXX)" || _die "Can't create temporary directory"
chmod 0700 "${tmp}"

#compile wrapper
_verbose "Generating wrapper \"${WRAPPER}\" -> \"${REAL}\""
_verbose "Owner: \"${OWNER}\", group: \"${GROUP}\", mode: \"${MODE}\""

WRAPPER_SRC="${tmp}/wrapper.c"
WRAPPER_BIN="${tmp}/wrapper"
_generate_source "${REAL}" >"${WRAPPER_SRC}"
${CC} -o "${WRAPPER_BIN}" "${WRAPPER_SRC}" || _die "Can't compile wrapper"

_mkdir_p "${DEST}" > /dev/null 2>&1
#install wrapper
install -o "${OWNER}" -g "${GROUP}" -m "${MODE}" -s \
    "${WRAPPER_BIN}" "${WRAPPER}" || _die "Can't install wrapper binary"

#delete temporary directory
rm -rf "${tmp}"; tmp=""
_verbose "Wrapper successfully generated and installed"
